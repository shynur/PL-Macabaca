# 名字

## 变量名

所有**纯大写字母构成的名字**是*保留字*, 不可用作*标识符*.
除此以外, *标识符*的合法性同 C 语言.

## 内置变量

*内置变量*存在于*全局环境*中, 包括但不限于: `True`, `False`, `Py`, `Get`.
它们皆以 **单个大写字母** 打头.

# 作用域

## 词法作用域

### 变量声明

变量必须先**声明** (可以不赋值, 但程序不应依赖未赋值的变量的值!), 方可使用.
被声明的变量会*遮蔽 (shadow)* 活跃的同名变量, 这一点与 Rust 一致.
例如,

```
LET n = 0;
LET n = n + 1;  # 先执行右侧表达式.  此时该行的‘LET’后的第一个‘n’还未被声明,
                # 所以第一行的‘n’仍处于活跃状态.
Print(n);       # ==> 打印‘1’
```

#### 递归函数的快捷定义

一个棘手的点是: 如何定义递归函数.
显然以下尝试定义阶乘函数的代码是失败的:

```
LET fact = |n| {
  IF n==0 {
    1
  } ELSE {
    n*fact(n-1)  # 当该函数被创建时, 并没有‘fact’处于活跃状态.
  }
};
fact(5);  # ==> Error!
```

所幸该编程语言是**基于表达式**的, 声明语句也不过是声明表达式加上了分号.
因此,

```
(LET fact) = |n| {
  IF n==0 {
    1
  } ELSE {
    n*fact(n-1)
  }
};
Print(fact(5));  # ==> 打印‘120’
```

此处**‘=’(赋值运算符) 左侧*表达式*被先执行** (别误会, ‘=’仍然是右结合的):
1. 词法变量‘fact’被声明, 此时它进入活跃状态;
2. ‘LET’表达式返回了‘fact’的*左值*;
3. 执行右侧表达式, 即创建匿名函数 (闭包).  它被创建时, 捕获了环境中活跃的‘fact’.
4. ‘fact’被赋值了右侧创建的闭包.

## 条件分支

```
IF 1 {2;}
IF 1 {2;} ELSE {3;}
IF 1 {2;} ELSE IF 3 {4;}
IF 1 {2;} ELSE IF 3 {4;} ELSE {5;}
```

## 循环

`FOR` 与 `WHILE` 是**同义词**.

循环由 循环头 和 循环体 组成, 循环头 有以下形式:

```
FOR b {}      FOR ;b {}     FOR ;b; {}
FOR a;b {}    FOR a;b; {}
FOR a;b;c {}
```

其中, ‘a’, ‘b’, ‘c’ 的含义类似 C 语言中的: ‘for(a;b;c){}’.



# API

## `True` and `False`

它们只是*全局变量*, 因此可以被*覆盖*.

例:

```
True = False;
True;      # => 打印出‘False’
NOT True;  # => 打印出‘True’
```

## `Get`

从*全局环境*中获取变量 (的左值).

例:

```
LET True: int = 0;  # 覆盖原本的‘True’
True;               # => 打印出‘0’
Get("True");        # => 打印出‘True’
```

## `Py`

调用 Python 中的 `eval` 函数.
